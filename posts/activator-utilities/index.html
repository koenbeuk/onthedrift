<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Activator utilities &#183; On the drift</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title="On the drift"></head><body><nav class=nav><div class=nav-container><a href=/><h2 class=nav-title>On the drift</h2></a><ul></ul></div></nav><main><div class=post><div class=post-info><span>Written by</span>
Koen<br><span>on&nbsp;</span><time datetime="2021-04-22 00:00:00 +0000 UTC">April 22, 2021</time></div><h1 class=post-title>Activator utilities</h1><div class=post-line></div><p>Dependency injection (DI) is a well-known technique that helps in writing more maintainable code. .NET has excellent support for Dependency injection and is heavily used in platforms such as ASP.NET Core.</p><h2 id=net-and-dependency-injection>.NET and Dependency injection</h2><p>In .NET, Dependencies are typically resolved through an interface <code>IServiceProvider</code>. This is backed by a DI container (ServiceProvider) that holds all registrations of possible instances, including their lifetimes. This means that the .NET DI Container is responsible for both managing registrations, lifetimes, and hooking them up together. For this post, I assume that you are familiar with DI and its implementation within .NET. To learn more about using DI in .NET, check out the official <a href=//docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection>Microsoft documentation</a>.</p><h2 id=resolving-dependencies>Resolving dependencies</h2><p>To resolve dependencies. You&rsquo;ll typically get your hands on an <code>IServiceProvider</code> instance. This same instance can then be used to dynamically resolve dependencies as shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> serviceProvider = <span style=color:#66d9ef>new</span> ServiceCollection()
      .AddTransient&lt;Services.TransientService&gt;()
      .BuildServiceProvider();

<span style=color:#66d9ef>var</span> service = serviceProvider.GetService&lt;TransientService&gt;();
</code></pre></div><p>This basic use-case of .NET&rsquo;s IServiceProvider works great when the dependency was registered beforehand with the ServiceProvider. But what if we want to get an instance of something that is not registered with the ServiceProvider:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyController</span> { 
    <span style=color:#66d9ef>public</span> MyControll(Services.TransientService service) { ... }
}

<span style=color:#66d9ef>var</span> serviceProvider = <span style=color:#66d9ef>new</span> ServiceCollection()
    .AddTransient&lt;Services.TransientService&gt;()
    .BuildServiceProvider();

<span style=color:#66d9ef>var</span> service = serviceProvider.GetService&lt;TransientService&gt;();

<span style=color:#75715e>// Attempt 1: Resolve it from the ServiceProvider
</span><span style=color:#75715e></span>serviceProvider.GetService&lt;MyController&gt;(); <span style=color:#75715e>// FAIL
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Attempt 2; Create an instance manually
</span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> MyController(<span style=color:#66d9ef>new</span> TransientService()); <span style=color:#75715e>// SUCCESS!
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Attempt 3: Create an instance and resolve arguments through DI
</span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> MyController(serviceProvider.GetService&lt;TransientService&gt;()); <span style=color:#75715e>// SUCCESS!
</span></code></pre></div><p>In this case, Attempt 1 fails. The reason for this is that MyController was never registered with the DI container and therefore, the DI container would not be able to know anything about the lifetime of MyController. In this example, MyController is not even a dependency but rather a consumer.</p><p>Attempt 2 succeeds as it just works around DI altogether! Not great as we&rsquo;re now back to square 1 and responsible for constructing and managing the lifetime of the Service we just created.</p><p>So what about attempt 3? Well, it&rsquo;s a legitimate use case as it resolves dependencies from the DI container while we still manage construction and the lifetime of our consumer class. However, it can get a bit tedious. What if we required more than 1 dependency? We would have to make a call to ServiceProvider.GetService for each dependency. Perhaps worse: What if we did not know about the type of MyController at compile time? This is exactly the problem that ASP.NET MVC is facing where it has to construct Controllers of which it did know nothing of at compile-time and yet has to fulfill all dependencies.</p><p>So now we&rsquo;re dealing with 2 subsequent issues:
How can we create an instance of a type when we know at compile-time, the constructor but not the type?
How can we create an instance of a type when we know neither the type nor the constructor at compile-time?</p><p>Luckily there is an easy answer and it&rsquo;s more powerful than you think!</p><h2 id=the-manual-approach>The manual approach</h2><p>When taking a dependency on the package: Microsoft.Extensions.DependencyInjection you&rsquo;ll get a type called <code>ActivatorUtilities</code> for free! But before we head into that, let&rsquo;s see if we can at least tackle some of these issues ourselves. First off:</p><h3 id=how-can-instantiate-mycontroller-at-runtime-when-we-know-the-constructor-but-not-the-type>How can instantiate MyController at runtime when we know the constructor but not the type?</h3><p>There is an easy way to this within just .NET, there are several.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> controllerType = <span style=color:#66d9ef>typeof</span>(MyController);

<span style=color:#75715e>// Attempt 1
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> controller = controllerType
              .GetConstructor(<span style=color:#66d9ef>new</span>[] { <span style=color:#66d9ef>typeof</span>(TransientService) })
              .Invoke(<span style=color:#66d9ef>new</span>[] { ServiceProvider.GetService&lt;TransientService&gt;()  }); <span style=color:#75715e>// WORKS
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Attempt 2
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> controller = Activator.CreateInstance(controllerType, ServiceProvider.GetService&lt;TransientService&gt;()); <span style=color:#75715e>// WORKS
</span><span style=color:#75715e></span>
</code></pre></div><p>Attempt 2 shows the use of the <code>Activator</code> class which has been around since the early days of .NET. It&rsquo;s a powerful tool in your arsenal that can be used to creates an instance of the specified type using the constructor that best matches the specified parameters.</p><p>Great, so now we know how to create an instance of a type without having to know the type at compile-time. So what about our next issue?</p><h3 id=how-can-we-create-an-instance-of-a-type-when-we-know-neither-the-type-nor-the-constructor-at-compile-time>How can we create an instance of a type when we know neither the type nor the constructor at compile-time?</h3><p>Now it gets a bit trickier. Both attempts shown above to create a new instance of a type at runtime require us to pass in an array of arguments that match in number, order, and type the parameters of the constructor to invoke.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> controllerType = <span style=color:#66d9ef>typeof</span>(MyController); <span style=color:#75715e>// Imagine we don&#39;t know this at compile time
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>var</span> constructor = controllerType.GetConstructors().Single();
<span style=color:#66d9ef>var</span> controller = constructor.Invoke(
        constructor.GetParameters()
            .Select(parameter =&gt; ServiceProvider.GetService(parameter.ParameterType))
            .ToArray()
        );
</code></pre></div><p>There is no obvious advantage of using the <code>Activator</code> class here since we had to rely on Reflection to get a constructor to invoke. We also introduced the assumption that our type always has just one controller. Not great but it kinda&mldr; works.</p><h2 id=introducing-activatorutilities>Introducing ActivatorUtilities</h2><p>Since instantiating a type at runtime with constructor arguments resolved from an <code>IServiceProvider</code> is not an easy process. Microsoft included a powerful but not well-known class called <code>ActivatorUtilities</code>. This can be found in the <code>Microsoft.Extensions.DependencyInjection.Abstractions</code> NuGet package which you&rsquo;ll likely already have an (in)direct dependency on. Our last example can be rewritten with ease as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> controller = ActivatorUtilities.CreateInstance&lt;MyController&gt;(ServiceProvider);
</code></pre></div><p><code>ActivatorUtilities</code> will now create an instance of MyController by calling its constructor with any dependencies resolved through the <code>IServiceProvider</code>. This is excellent, so we&rsquo;re done right? Well, no. First, remember that assumption where we assumed that there was only 1 constructor. Let&rsquo;s take that assumption away and see what happens.</p><h3 id=activation-patterns>Activation patterns</h3><p>Let&rsquo;s first assume that <code>MyController</code> has 2 constructors. One taking no arguments and the other taking a <code>TransientService</code> argument (which is registered with our DI container). How will ActivatorUtilities behave in this case?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyController</span> { 
    <span style=color:#66d9ef>public</span> MyController() { 
        Console.WriteLine(<span style=color:#e6db74>&#34;Feeling empty!&#34;</span>);
    } 
    <span style=color:#66d9ef>public</span> MyController(TransientService service) {
        Console.WriteLine(<span style=color:#e6db74>&#34;I&#39;ve been served!&#34;</span>);
    }
}

<span style=color:#66d9ef>var</span> subject = ActivatorUtilities.CreateInstance&lt;MyController&gt;(ServiceProvider);
</code></pre></div><p>When we run this code we&rsquo;ll find that &lsquo;Feeling empty!&rsquo; gets written to the console. Does this mean that ActivatorUtitilies looks for the most fitting constructor (and in this case, the one with the least amount of work)? Well, the answer is no, <code>ActivatorUtilities</code> simply picks the first constructor that can do the job. So if the constructor that takes in the service was declared above the parameterless constructor then MyController would have been instantiated using that constructor. Only public constructors are considered.</p><p>We can however tell ActivatorUtilities which constructor to use, for this we have the <code>ActivatorUtilitiesConstructorAttribute</code> available. When applied to a constructor, this constructor will always be used by ActivatorUtilities.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyController</span> { 
    <span style=color:#66d9ef>public</span> MyController() { 
        Console.WriteLine(<span style=color:#e6db74>&#34;Feeling empty!&#34;</span>);
    } 
<span style=color:#a6e22e>    [ActivatorUtilitiesConstructor]</span>
    <span style=color:#66d9ef>public</span> MyController(TransientService service) {
        Console.WriteLine(<span style=color:#e6db74>&#34;I&#39;ve been served!&#34;</span>);
    }
}

<span style=color:#66d9ef>var</span> subject = ActivatorUtilities.CreateInstance&lt;MyController&gt;(ServiceProvider);
</code></pre></div><p>As expected, this will write: &lsquo;I&rsquo;ve been served!&rsquo; to the console. You can only apply ActivatorUtilitiesConstructor to one constructor otherwise, you&rsquo;ll get an InvalidOperationException during runtime.</p><p>There is a third way of selecting what constructor should be used, this can be done through explicit arguments.</p><h3 id=explicit-arguments>Explicit arguments</h3><p>ActivatorUtilties allows you to specify constructor arguments manually, lets take our previous controller and create an instance with an explicit transient service and see what happens:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyController</span> { 
    <span style=color:#66d9ef>public</span> MyController() { 
        Console.WriteLine(<span style=color:#e6db74>&#34;Feeling empty!&#34;</span>);
    } 
    <span style=color:#66d9ef>public</span> MyController(TransientService service) {
        Console.WriteLine(<span style=color:#e6db74>&#34;I&#39;ve been served!&#34;</span>);
    }
}

<span style=color:#66d9ef>var</span> subject = ActivatorUtilities.CreateInstance&lt;MyController&gt;(ServiceProvider, <span style=color:#66d9ef>new</span> TransientService());
</code></pre></div><p>In this case again, &lsquo;I&rsquo;ve been served!&rsquo; is written to the console. Remember that ActivatorUtitilties picks the first constructor that can do the job. In this case, our first empty does not accept any arguments while one explicit argument is given so it&rsquo;s not considered as a valid candidate.
If we were to provide additional explicit arguments then we would get an <code>InvalidOperationException</code> informing us that no suitable constructor for activation could be located.</p><p>This is not only useful for selecting what constructor should be used. It also allows us to pass in explicit arguments that could or should otherwise not be resolved through dependency injection. Let&rsquo;s take a look at an example.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyController</span> { 
    <span style=color:#66d9ef>public</span> MyController(ITransientService service1, CancellationToken cancellationToken, ISingletonService service2) { ... }
}

<span style=color:#66d9ef>var</span> cancellationTokenSource = <span style=color:#66d9ef>new</span> CancellationTokenSource();
<span style=color:#66d9ef>var</span> subject = ActivatorUtilities.CreateInstance&lt;MyController&gt;(ServiceProvider, cancellationTokenSource.Token);
</code></pre></div><p>Not only were we able to provide an argument that would otherwise not be resolved through our DI container, but we were also still able to accept that argument in our constructor in whatever order we like. ActivatorUtilities only cares for the order of explicit arguments when multiple arguments are provided that are of the same type.</p><h3 id=activation-methods>Activation methods</h3><p>So far you&rsquo;ve seen an overload that requires an explicit type argument. However, just like our old Activator class, we also have an overload available that accepts a Type argument as shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> controller = ActivatorUtilities.CreateInstance(ServiceProvider, <span style=color:#66d9ef>typeof</span>(Subject));
</code></pre></div><p>This is ideal for when you don&rsquo;t know the actual type that you&rsquo;re constructing at compile time.</p><p>There is also an overload that returns a delegate that can be invoked to create an instance, optionally accepting explicit arguments. Let see an example.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> factory = ActivatorUtilities.CreateFactory(<span style=color:#66d9ef>typeof</span>(Subject), <span style=color:#66d9ef>new</span> Type[] { });
<span style=color:#66d9ef>var</span> instance = factory.Invoke(ServiceProvider, <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>as</span> Subject;
</code></pre></div><p>Or when using explicit arguments</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> factory = ActivatorUtilities.CreateFactory(<span style=color:#66d9ef>typeof</span>(Subject), <span style=color:#66d9ef>new</span> Type[] { <span style=color:#66d9ef>typeof</span>(TransientService) });

<span style=color:#66d9ef>var</span> service = <span style=color:#66d9ef>new</span> TransientService();
<span style=color:#66d9ef>var</span> instance = factory.Invoke(ServiceProvider, <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[] { service }) <span style=color:#66d9ef>as</span> Subject;
</code></pre></div><p>This is particularly useful when performance is an issue as a suitable constructor is only located and analyzed once.</p><p>A third and less prominent feature is <code>GetServiceOrCreateInstance</code>. This little-known feature enables default or fallback implementations in case our DI container was not directly able to resolve an instance. Consider that we were in the need of an instance of a controller. It would be great if we could 1. Check with our DI container if it can resolve an instance of our controller and if not, create an instance ourselves.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#66d9ef>var</span> controller = ActivatorUtilities.GetServiceOrCreateInstance(ServiceProvider, <span style=color:#66d9ef>typeof</span>(MyController));
</code></pre></div><p>As a consumer of this code, I would only need to care that my controller can be resolved from the DI container, and optionally I could register it so that I can also control its lifetime.</p><h2 id=conclusion>Conclusion</h2><p>ActivatorUtilities is a powerful tool in your belt when dealing with DI in general. You may not need it often but when you do, it&rsquo;s there and it just works. So how what does the future have in place for ActivatorUtilities? Well, probably not that much. It&rsquo;s rich in features already as code generation is on the horizon as a potential alternative.</p></div><div class=pagination><a href=/posts/hello-world/ class="left arrow">&#8592;</a>
<a href=# class=top>Top</a></div></main><footer><span>&copy; <time datetime="2021-04-22 11:15:48.1835984 +0000 UTC m=+0.043055901">2021</time> Koen</span></footer></body></html>